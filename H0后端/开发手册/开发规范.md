## 分支管理模型

### GitFlow

该模型中存在两种长期分支：`master` 和 `develop`。 `master`中存放对外发布的版本，只有稳定的发布版本才会合并到`master`中。 `develop`用于日常开发，存放最新的开发版本。

也存在三种临时分支：`feature`, `hotfix`, `release`。

- `feature`分支是为了开发某个特定功能，从`develop`分支中切出，开发完成后合并到`develop`分支中。
- `hotfix`分支是修复发布后发现的Bug的分支，从`master`分支中切出，修补完成后再合并到`master`和`develop`分支。
- `release`分支指发布稳定版本前使用的预发布分支，从`develop`分支中切出，预发布完成后，合并到`develop`和`master`分支中。

优点：

- `feature` 分支使开发代码隔离，可以独立的完成开发、构建、测试
- `feature` 分支开发周期长于`release`时，可避免未完成的`feature`进入生产环境

缺点：

- 无法支持持续发布。
- 过于复杂的分支管理，加重了开发者的负担，使开发者不能专注开发。

------

### GitHubFlow

`GitHubFlow`分支模型只存在一个`master`主分支，日常开发都合并至`master`，永远保持其为最新的代码且随时可发布的。

- 在需要添加或修改代码时， 基于`master`创建分支，提交修改。
- 创建`Pull Request`，所有人讨论和审查你的代码。
- 然后部署到生产环境中进行验证。
- 待验证通过后合并到`master`分支中。

这个分支模型的优势在于简洁易理解，将`master`作为核心的分支，代码更新持续集成至`master`上。根据目前收集到的反应来看，得到了更多的好评，认为`GitHubFlow`分支模型更加轻便快捷。

------

### GitLabFlow

`GitLabFlow` 是`GitFlow`和`GitHubFlow`的结合,它吸取了两者的优点，既有适应不同开发环境的弹性，又有单一主分支的简单和便利。

该模型采取上游优先的原则，即只存在一个`master`主分支，它是所以分支的上游。只有上游分支采纳的变动才能应用到其他分支。

- 对于持续发布的项目，建议在`master`之外再建立对应的环境分支，如预生产环境`pre-production`，生产环境`production`。
- 对于版本发布的项目，建议基于`master`创建稳定版本对应的分支，如`stable-1`，`stable-2`。

------

### HZERO

HZERO中采取了`GitFlow`的模式，并提供多种分支类型。

------

### 分支命名规约

| 前缀       | 含义                                     |
| :--------- | :--------------------------------------- |
| master     | 主分支，可用的、稳定的、可直接发布的版本 |
| develop    | 开发主分支，最新的代码分支               |
| feature-** | 功能开发分支                             |
| bugfix-**  | 未发布bug修复分支                        |
| release-** | 预发布分支                               |
| hotfix-**  | 已发布bug修复分支                        |

------

### 提交命名规约

除了分支的名称需要规范，提交的命名也同样如此。猪齿鱼并没有把这个规则固化到系统中，需要团队共同遵守。

格式为：[操作类型]操作对象名称，如[ADD]readme，代表增加了readme描述文件。

常见的操作类型有：

- [IMP] 提升改善正在开发或者已经实现的功能
- [FIX] 修正BUG
- [REF] 重构一个功能，对功能重写
- [ADD] 添加实现新功能
- [REM] 删除不需要的文件

------

## 版本号规范

版本格式：主版本号.次版本号.修订号，版本号递增规则如下：

1.主版本号：当你做了不兼容的 API 修改。

2.次版本号：当你做了向下兼容的功能性新增。

3.修订号：当你做了向下兼容的问题修正。

先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。

------

### 需求与代码关联

在 HZERO 中，可以通过 Issue 创建分支，或者创建分支时选择关联的 Issue，通过这种方式将需求与代码进行关联。

这样，我们可以追溯到一个用户故事对应了哪些分支，哪几个提交， 甚至出现了一些 BUG，可以找到是哪个分支提交的，当初为了发布XXX新的需求，不仅如此，我们通过需求与代码分支关连，能够查看到哪些需求已经部署到了测试环境，那些需求已经部署到了正式环境，以及从业务到代码的整个链条的统计分析。

------

## 语义化版本

>使用语义化版本控制(`Semantic Versioning`)，你必须先有定义好的公共 API 。这可以透过文件定义或代码强制要求来实现(API 文档)。无论如何，这套 API 的清楚明了是十分重要的。一旦你定义了公共 API，你就可以透过修改相应的版本号来向大家说明你的修改。考虑使用这样的版本号格式：X.Y.Z （主版本号.次版本号.修订号），先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。
>
>版本号递增规则如下
>主版本号：当你做了不兼容的 API 修改，递增主版本号
>次版本号：当你做了向下兼容的功能性新，递增次版本号
>修订号：当你做了向下兼容的问题修正，递增修订号

### 语义化版本控制规范

- 使用语义化版本控制的软件`必须`定义公共 API。该 API 可以在代码中被定义或出现于严谨的文件内。无论何种形式都应该力求精确且完整。
- 标准的版本号`必须`采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且`禁止`在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素`必须`以数值来递增。例如：1.9.1 -> 1.10.0 -> 1.11.0。
- 标记版本号的软件发行后，`禁止`改变该版本软件的内容。任何修改都`必须`以新版本发行。
- 主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。**以 `0.1.0` 作为你的初始化开发版本，并在后续的每次发行时递增次版本号**
- <font color='red'>1.0.0 的版本号用于界定公共 API 的形成。</font>这一版本之后所有的版本号更新都基于公共 API 及其修改内容。**当你的软件被用于正式环境，它应该已经达到了 `1.0.0` 版。**

- 修订号 Z（x.y.Z | x > 0）`必须`在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。
- 次版本号 Y（x.Y.z | x > 0）`必须`在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也`必须`递增。也`可以`在内部程序有大量新功能或改进被加入时递增，其中`可以`包括修订级别的改变。每当次版本号递增时，修订号`必须`归零。
- 主版本号 X（X.y.z | X > 0）`必须`在有任何不兼容的修改被加入公共 API 时递增。其中`可以`包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号`必须`归零。
- 先行版本号`可以`被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符号来修饰。标识符号`必须`由 ASCII 码的英数字和连接号 [0-9A-Za-z-] 组成，且`禁止`留白。数字型的标识符号`禁止`在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法达到兼容的需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。
- 版本编译信息`可以`被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符号来修饰。标识符号`必须`由 ASCII 的英数字和连接号 [0-9A-Za-z-] 组成，且`禁止`留白。当判断版本的优先层级时，版本编译信息可被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。
- 版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，`必须`把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较。由左到右依序比较每个标识符号，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较，例如：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。例如：1.0.0-alpha < 1.0.0。有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级`必须`透过由左到右的每个被句点分隔的标识符号来比较，直到找到一个差异值后决定：只有数字的标识符号以数值高低比较，有字母或连接号时则逐字以 ASCII 的排序来比较。**数字的标识符号比非数字的标识符号优先层级低。**若开头的标识符号都相同时，栏位比较多的先行版本号优先层级比较高。范例：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0- rc.1 < 1.0.0。

------

### 版本号信息

- **alpha**：内部测试版。α是希腊字母的第一个，表示最早的版本，一般用户不要下载这个版本，这个版本包含很多BUG，功能也不全，主要是给开发人员和测试人员测试和找BUG用的。
- **beta**：公开测试版。β是希腊字母的第二个，顾名思义，这个版本比alpha版发布得晚一些，主要是给“部落”用户和忠实用户测试用的，该版本任然存在很多BUG，但是相对alpha版要稳定一些。这个阶段版本的软件还会不断增加新功能。如果你是发烧友，可以下载这个版本。
- **RC**(Release Candidate)：候选版本。该版本又较beta版更进一步了，该版本功能不再增加，和最终发布版功能一样。这个版本有点像最终发行版之前的一个类似预览版，这个的发布就标明离最终发行版不远了。作为普通用户，如果你很急着用这个软件的话，也可以下载这个版本。
- **stable**：稳定版。在开源软件中，都有stable版，这个就是开源软件的最终发行版，用户可以放心大胆的用了。
- **RELEASE**：最终版本。在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release不会以单词形式出现在软件封面上，取而代之的是符号®。

------

## 命名规约

### 服务配置

在开发过程中需要用到很多配置，为了保持可读性和维护性，配置段不宜过多，控制在4~5段即可，其中第一段为固定段：hzero，第二段为服务/组件段，第三、四段为规则段，最后一段为配置值。例：系统启动是否开启Redis初始化的配置，`hzero:platform:init-cache:false`

------

### 值集数据配置

- 按功能划分（仅本功能使用）
  服务模块+功能+用途，如：`HPFM.CODE_RULE.FIELD_TYPE`（编码规则字段类型）
- 按服务划分（服务内可通用）
  服务模块+用途，如：`HPFM.FLAG`（标识）
- 按全局划分（所有服务通用）
  HPFM（平台服务）、HMDM（主数据服务）下的服务级值集，其他服务都可直接使用，如：HPFM.TEXT_TYPE（文本类型）
- **`值集使用说明`**：
  由于值集存在共用情况，在创建值集时需要先去判断是否已登记存在，如果存在则与负责人（技术设计者和业务负责人）沟通是否可以直接使用，避免重复造轮子和引起混乱。

查询途径：

1.后台SQL查询（在平台服务数据库hzero_platform中执行以下语句）

```SQL
SELECT l.lov_code,
       lt.description lov_description,
       lv.`value`,
       lvt.meaning,
       lvt.description value_description
  FROM hpfm_lov l,
       hpfm_lov_tl lt,
       hpfm_lov_value lv,
       hpfm_lov_value_tl lvt
 WHERE l.lov_id = lt.lov_id
   AND l.lov_id = lv.lov_id
   AND lv.lov_value_id = lvt.lov_value_id
   AND l.lov_type_code = 'IDP'
   AND lt.description LIKE '%维度%'
```

2.系统中对应界面的功能查询

3.在项目基础设置登记的Excel中进行查询

------

### LOV应用配置

- 命名规则参考值集命名（1、2、3）
- **注意：** 不存在LOV应用配置全局划分情况，每个微服务的LOV应用配置都是服务下，`前端开发引用时需要特别注意，不能跨服务调用，以避免后续拆分造成问题`。

------

### 编码规则配置

- 按功能划分（仅本功能使用）
  服务模块+功能+用途，如：`HPFM.USER.USERNAME`（平台服务.用户管理.用户名）
- 按服务划分（服务内可通用）
  服务模块+用途，如：`HIMP.BATCH_ID`（导入服务.批次号）

> **`以上规范注意事项`**
> 编码的代码统一大写
> 定义代码时尽量用英文或英文简称，并且不宜过长
> 描述尽量表达清楚
> 每个段之间用点号“.”隔开
> 一段中如果存在多个单词，用下划线`_`隔开

------

### 消息模板代码

- 按功能划分（仅本功能使用）
  服务模块+功能+用途，如：`HIAM.USER.REGISTER`IAM服务.用户.注册成功通知）
- 按服务划分（服务内可通用，HPFM服务下的服务级全局可通用）
  服务模块+用途，如：`HPFM.VERIFICATION_CODE`（平台服务.验证码）

> **`以上规范注意事项`**
> 编码的代码统一大写
> 定义代码时尽量用英文或英文简称，并且不宜过长
> 描述尽量表达清楚
> 每个段之间用点号“.”隔开
> 一段中如果存在多个单词，用下划线`_`隔开

------

### 多语言描述维护

##### 多语言标签

- 按功能划分（仅本功能使用）
  服务模块+功能+用途，如：`hpfm.user.age`（年龄）
- 按服务划分（服务内可通用）
  服务+用途，如：`hiam.common.menu`（菜单）
- 按全局划分（所有服务通用）
  HPFM（平台服务）、HMDM（主数据服务）下的服务级值集，其他服务都可直接使用，如：`hpfm.common.userName`（用户名）

##### 返回消息

- 按功能划分（仅本功能使用）
  服务模块+类型+功能+用途，如：`hpfm.error.user.ageNull`（年龄不能为空）
- 按服务划分（服务内可通用）
  服务模块+类型+用途，如：`hpfm.error.menuNameNull`（菜单名称不能为空）
- 按全局划分（所有服务通用）
  HPFM（平台服务）、HMDM（主数据服务）下的服务级值集，其他服务都可直接使用，如：`hpfm.error.noAuth`（没有操作权限，请联系管理员）

> **`多语言规范注意事项`**
> 快速编码的代码统一小写
> 定义代码时尽量用英文或英文简称，并且不宜过长
> 描述尽量表达清楚
> 每个段之间用点号“.”隔开 一段中如果存在多个单词，使用`驼峰`方式
> 多语言描述，`一二段`对应prompt_key，`三四段`对应prompt_code
> 返回消息，第二段的类型只能是`error`,`info`,`warn`,为了与界面返回消息配置对应，请不要随意发挥