# 项目规约

## 命名规范

- 项目从大到小可分为产品、服务、组件，产品以产品名称命名，如`hzero`、`oa`、`srm`。
- 一个产品下划分多个服务，命名规则：产品名-模块名，如`hzero-platform`、`oa-contract`。
- 如果产品下有组件，命名格式：产品名-boot-组件名，如`hzero-boot-platform`、`hzero-boot-common`。

## GAV的定义

定义 `GAV` 遵从以下规则：

- `GroupID` 格式： org.[组织/BU].[子业务线]，最多 4 级。
  正例： org.hzero 或 org.hzero.boot
- `ArtifactID` 格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。
  正例： hzero-platform / hzero-mdm / hzero-boot-common
- `Version`：初始化版本定义为`0.1.0-SNAPSHOT`，详细规定参考[语义版本规范](http://hzerodoc.saas.hand-china.com/zh/docs/development-specification/backent-development-specification/structure/project/semver.html)。

服务：

```xml
<groupId>org.hzero</groupId>
<artifactId>hzero-platform</artifactId>
<version>1.0.0</version>
```

服务组件：

```xml
<groupId>org.hzero.boot</groupId>
<artifactId>hzero-boot-common</artifactId>
<version>1.0.0</version>
```

通用组件：

```xml
<groupId>org.hzero.starter</groupId>
<artifactId>hzero-starter-export</artifactId>
<version>1.0.0</version>
```

------

## 依赖规范

##### 强制要求

1. 二方库版本号命名方式：主版本号.次版本号.修订号

   - 主版本号： 产品方向改变， 或者大规模 API 不兼容， 或者架构不兼容升级。
   - 次版本号： 保持相对兼容性，增加主要功能特性， 影响范围极小的 API 不兼容修改。
   - 修订号： 保持完全兼容性， 修复 BUG、 新增次要功能特性等。
     说明： 以 `0.1.0-SNAPSHOT` 作为初始化开发版本，并在后续的每次发行时递增次版本号。当软件被用于正式环境，起始版本号为 `1.0.0` 版。正式发布的类库必须先去中央仓库进行查证，使版本号有延续性， 正式版本号不允许覆盖升级。如当前版本： 1.3.3， 那么下一个 合理的版本号： 1.3.4 或 1.4.0 或 2.0.0

2. 线上应用不要依赖 SNAPSHOT 版本（安全包除外）。
   说明： 不依赖 SNAPSHOT 版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。

   **注：**Snapshot版本代表不稳定、尚处于开发中的版本；Release版本则代表稳定的版本

3. 二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变， 必须明确评估和验证， 建议进行 `dependency:resolve` 前后信息比对，如果仲裁结果完全不一致，那么通过 `dependency:tree` 命令，找出差异点，进行`<excludes>`排除 jar 包。

4. 二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的 POJO 对象。

5. 依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。
   说明： 依赖 springframework-core,-context,-beans，它们都是同一个版本，可以定义一个变量来保存版本： ${spring.version}，定义依赖的时候，引用该版本。

6. 禁止在子项目的 pom 依赖中出现相同的 GroupId，相同的 ArtifactId，但是不同的Version。
   说明： 在本地调试时会使用各子项目指定的版本号，但是合并成一个 war，只能有一个版本号出现在最后的 lib 目录中。 可能出现线下调试是正确的，发布到线上却出故障的问题。

##### 推荐

1. 所有 pom 文件中的依赖声明放在`<dependencies>`语句块中，所有版本仲裁放在`<dependencyManagement>`语句块中。
   说明： `<dependencyManagement>` 里只是声明版本，并不实现引入，因此子项目需要显式的声明依赖， `version` 和 `scope` 都读取自父 pom。而 `<dependencies>` 所有声明在主 pom 的`<dependencies>`里的依赖都会自动引入，并默认被所有的子项目继承。
2. 二方库不要有配置项，最低限度不要再增加配置项。
3. 为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：
   - 精简可控原则。移除一切不必要的 API 和依赖，只包含 Service API、必要的领域模型对象、 Utils 类、常量、枚举等。如果依赖其它二方库，尽量是 `provided` 引入，让二方库使用者去依赖具体版本号； 无 log 具体实现，只依赖日志框架。
   - 稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。

------

# 应用分层

## DDD 代码架构

### 大的层次上分为四层

- api：用户接口层，向外提供服务
- app：应用层，包含应用服务，负责用例流程调度，事务控制
- domain：领域层，包含领域对象和领域服务，专注核心业务
- infra：基础设施层，提供数据持久化、防腐层实现、第三方库、消息等
- <img src="http://hzerodoc.saas.hand-china.com/img/docs/development-specification/backend-development-specification/structure/1529378488.jpg" alt="img" style="zoom:80%;" />

### api 层

- controller：提供资源服务，XxxController.java
- dto：数据传输对象，XxxDTO.java，对于一些复杂页面需要多个实体组合时，可使用DTO对象来传输数据。
- <img src="http://hzerodoc.saas.hand-china.com/img/docs/development-specification/backend-development-specification/structure/1529378664.jpg" alt="img" style="zoom:80%;" />

### app 层

- service：应用服务，XxxService.java，应用服务里进行事务控制，流程调度
- service.impl：应用服务实现，XxxServiceImpl.java
- assembler：DTO组装器，XxxAssembler.java，复杂DTO的组装，简单的直接使用Entity即可
- <img src="http://hzerodoc.saas.hand-china.com/img/docs/development-specification/backend-development-specification/structure/1529380984.jpg" alt="img" style="zoom:80%;" />

### domain 层

- entity：实体对象，与表做映射，具备一些简单的自治的业务方法
- service：领域服务，命名一般按提供的业务功能命名，通常用于封装一个领域内的复杂业务逻辑，简单的业务逻辑在 app 层完成即可，不需要领域层。
- repository：资源库接口，XxxRepository.java，提供数据资源的操作方法，如数据库增删改查、Redis增删改查等，查询操作建议写到 repository 内。
- vo：值对象，XxxVO.java，领域内用到的数据封装，对于一些没有实体对象的数据对象但又在领域中用到，使用值对象封装
- <img src="http://hzerodoc.saas.hand-china.com/img/docs/development-specification/backend-development-specification/structure/1529381056.jpg" alt="img" style="zoom:80%;" />

### infra 层

- mapper：Mapper接口，XxxMapper.java
- repository.impl：资源库实现，XxxRepositoryImpl.java，业务一定不要侵入到这里
- constant：常量
- util：工具
- <img src="http://hzerodoc.saas.hand-china.com/img/docs/development-specification/backend-development-specification/structure/1529383140.jpg" alt="img" style="zoom:80%;" />

### 最简单的DDD架构

至少需要包含如下的结构，将业务和流程分开，应用服务专注用例调度，反应用户故事；领域对象/服务专注核心业务。整个模块通用的放到基础设施层，资源库和外部服务实现也放到基础设施层，屏蔽实现细节。

```
└─src
    ├─main
    │  ├─java
    │  │  └─com
    │  │      └─hand
    │  │          └─<module>
    │  │              ├─api
    │  │              │  ├─controller
    │  │              │  │   └─v1
    │  │              │  │      └─XxxController.java
    │  │              │  └─dto
    │  │              │      └─XxxDTO.java
    │  │              │
    │  │              ├─app
    │  │              │  └─service
    │  │              │      ├─XxxService.java
    │  │              │      └─impl
    │  │              │          └─XxxServiceImpl.java
    │  │              │
    │  │              ├─domain
    │  │              │  ├─entity
    │  │              │  │   └─Xxx.java
    │  │              │  └─repository
    │  │              │      └─XxxRepository.java
    │  │              │
    │  │              └─infra
    │  │                 ├─mapper
    │  │                 │   └─XxxMapper.java
    │  │                 └─repository
    │  │                     └─impl
    │  │                         └─XxxRepositoryImpl.java
    │  │
    │  └─resources
    │
    └─test
```